/*
 * Created on Dec 15, 2005
 */
package org.gk.IDGeneration;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.gk.model.GKInstance;
import org.gk.persistence.MySQLAdaptor;
import org.gk.schema.SchemaClass;

/** 
 *  Generates a list of stable IDs, given a list of
 *  Instance classes for ID generation, the database 
 *  adaptor for the previous release and the database
 *  adaptor for the curent release.  Method:
 *  
 *  generateIDs
 *  
 *  Its also possible to run a set of standard tests on the
 *  stable IDs generated in this way.  Test results are
 *  stored internally.  Methods:
 *  
 *  testIDs
 *  getTests
 *  
 * @author croft
 */
public class IDGenerator {
	private IDGeneratorTests tests; // list of tests performed
	private IdentifierDatabase identifierDatabase;
	private MySQLAdaptor previousDba = null;
	private MySQLAdaptor currentDba = null;
	private MySQLAdaptor gk_centraldba = null;
	private PreviousInstanceFinder previousInstanceFinder;
	private String currentReleaseNum;
	
	/**
	 * Requires as arguments the database adaptors for the main
	 * databases that will be dealt with, namely, the previous
	 * and current releases, plus the development database (usually
	 * called gk_central or something similar).  If previousDba
	 * is null, it is assumed that currentDba is the very first
	 * database in a series of releases, and brand new stable IDs
	 * will be generated.  If a previousDba is also specified,
	 * then stable IDs will be carried over from the previous
	 * to the current release where possible.  If gk_centraldba
	 * is specified, checks will also be made for instances
	 * marked as "_doRelease".
	 * 
	 * @param previousDba - can be null
	 * @param currentDba - must be defined
	 * @param gk_centraldba - can be null
	 */
	public IDGenerator(MySQLAdaptor previousDba, MySQLAdaptor currentDba, MySQLAdaptor gk_centraldba, IdentifierDatabase identifierDatabase) {
		this.previousDba = previousDba;
		this.currentDba = currentDba;
		this.gk_centraldba = gk_centraldba;
		this.identifierDatabase = identifierDatabase;
		
		previousInstanceFinder = new DbIdPreviousInstanceFinder(currentReleaseNum, previousDba, true, identifierDatabase);
	}
	
	public IDGenerator(MySQLAdaptor previousDba, MySQLAdaptor currentDba, MySQLAdaptor gk_centraldba, IdentifierDatabase identifierDatabase, PreviousInstanceFinder previousInstanceFinder) {
		this.previousDba = previousDba;
		this.currentDba = currentDba;
		this.gk_centraldba = gk_centraldba;
		this.identifierDatabase = identifierDatabase;
		this.previousInstanceFinder = previousInstanceFinder;
	}
	
	/**
	 * Takes the list of schema classes and generates stable IDs for
	 * all instances in these classes.  Reactome database and identifier
	 * database are updated to contain the new stable IDs.
	 * 
	 * @param classes
	 */
	public void generateIDs(List classes) {
		generateIDs(classes, false, null);
	}
	
	/**
	 * Takes the list of schema classes and generates stable IDs for
	 * all instances in these classes.  Reactome database and identifier
	 * database are updated to contain the new stable IDs.
	 * 
	 * @param classes
	 */
	public void generateIDs(List classes, List schemaChangeIgnoredAttributes) {
		generateIDs(classes, false, schemaChangeIgnoredAttributes);
	}
	
	/**
	 * Takes the list of schema classes and generates stable IDs for
	 * all instances in these classes.  Reactome database and identifier
	 * database are updated to contain the new stable IDs.
	 * 
	 * @param classes
	 * @param testMode - if true, nothing will be inserted into database
	 */
	public void generateIDs(List classes, boolean testMode, List schemaChangeIgnoredAttributes) {
		currentReleaseNum = identifierDatabase.getReleaseNumFromReleaseDba(currentDba);
		if (currentReleaseNum==null || currentReleaseNum.equals("")) {
			System.err.println("IDGenerator.generateIDs: no release specified, cannot proceed");
			return;
		}

		// Make sure that the most recent stable ID has a sane value,
		// to avoid possible stable ID duplications.
		IdentifierDatabase.sanitizeMostRecentStableIdentifierFromState(previousDba);
		
		// Stash the largest known DB_ID from the current release database
		if (!testMode) {
			long maxDbId = currentDba.fetchMaxDbId();
			if (maxDbId>=0)
				identifierDatabase.insertMaxDbId(currentReleaseNum, maxDbId);
		}
		
		if (classes==null)
			return;
		
		tests = new IDGeneratorTests();
		tests.setCurrentDba(currentDba);

		List consolidatedClasses = consolidateClassList(classes);
		
		// Go through all instances of each schema class .
		for (Iterator it = consolidatedClasses.iterator(); it.hasNext();) {
			SchemaClass currentSchemaClass = (SchemaClass)it.next();
				
			generateIDs(currentSchemaClass, testMode, schemaChangeIgnoredAttributes);
		}
		
		if (!testMode) {
			identifierDatabase.insertTests(currentReleaseNum, tests);
		}
		
		System.err.println("IDGenerator.generateIDs: finished.");
	}
	
	/**
	 * Takes a schema class and generates stable IDs for
	 * all instances in this class.
	 * 
	 * @param schemaClass
	 * @param testMode - if true, nothing will be inserted into database
	 */
	public void generateIDs(SchemaClass currentSchemaClass, boolean testMode, List schemaChangeIgnoredAttributes) {
		if (currentDba==null) {
			System.err.println("IDGenerator.generateIDs: currentDba==null!");
			return;
		}

		SchemaClass previousSchemaClass = null;
		if (previousDba!=null) {
			previousSchemaClass = previousDba.getSchema().getClassByName(currentSchemaClass.getName());
		}
		InstanceBiologicalMeaning instanceBiologicalMeaning = new InstanceBiologicalMeaning(currentSchemaClass, previousSchemaClass);
		try {
			Collection instances = currentDba.fetchInstancesByClass(currentSchemaClass);
			
			for (Iterator it = instances.iterator(); it.hasNext();) {
				GKInstance instance = (GKInstance)it.next();
				generateIDs(instanceBiologicalMeaning, instance, testMode, schemaChangeIgnoredAttributes);
			}
		} catch (Exception e) {
			System.err.println("IDGenerator.generateIDs: problem fetching instances");
			e.printStackTrace();
		}
		
		if (previousDba!=null && gk_centraldba!=null) {
			try {
				Collection instances = previousDba.fetchInstancesByClass(currentSchemaClass);
				
				for (Iterator it = instances.iterator(); it.hasNext();) {
					GKInstance instance = (GKInstance)it.next();
					generateDoNotReleaseIDs(instance, testMode);
					generateDeletionComments(instance, testMode);
				}
			} catch (Exception e) {
				System.err.println("IDGenerator.generateIDs: problem fetching instances");
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * 
	 * Look at things that have been deleted since the last release
	 * and make a note if they still exist in gk_central but have
	 * been marked as "do not release".
	 */
	public void generateDoNotReleaseIDs(GKInstance previousInstance, boolean testMode) {
		try {
			Long dbId = previousInstance.getDBID();
			
			GKInstance currentInstance = currentDba.fetchInstance(dbId);
			// Instance exists in current release too, i.e. has not
			// been delteted/suppressed, so we don't need to continue.
			if (currentInstance!=null)
				return;
			
			GKInstance gk_centralInstance = gk_centraldba.fetchInstance(dbId);
			// Instance does not exist in gk_central, i.e. has
			// been delteted, so we don't need to continue.
			if (gk_centralInstance==null)
				return;
			
//			// If _doRelease has been set, don't proceed any further.
//			Boolean doRelease = null;
//			try {
//				doRelease = (Boolean)gk_centralInstance.getAttributeValue("_doRelease");
//			} catch (InvalidAttributeException e) {
//				System.err.println("IDGenerator.generateDoNotReleaseIDs: cannot find a _doRelease attribute for dbId=" + dbId);
//			}
//			if (doRelease!=null && doRelease.booleanValue()) {
//				System.err.println("IDGenerator.generateDoNotReleaseIDs: dbId=" + dbId + " is present in gk_central and is marked for release, but is not actually present in the current release!  This instance will be falsely categorized as deleted by the web GUI.");
//				return;
//			}
			
			// Get StableIdentifier instance from release database
			GKInstance stableIdentifier = (GKInstance)previousInstance.getAttributeValue("stableIdentifier");
			if (stableIdentifier==null)
				return;
			
			String identifier = (String)stableIdentifier.getAttributeValue("identifier");
			
			// Get StableIdentifier instance from identifier database
			stableIdentifier = IdentifierDatabase.getStableIdentifierInstance(identifier, false);
			if (stableIdentifier==null)
				return;
			
			stableIdentifier.setAttributeValue("doNotRelease", currentReleaseNum);
			
			if (!testMode) {
				MySQLAdaptor identifierDatabaseDba = IdentifierDatabase.getDba();
				identifierDatabaseDba.updateInstanceAttribute(stableIdentifier, "doNotRelease");
			}
		} catch (Exception e) {
			System.err.println("IDGenerator.generateDoNotReleaseIDs: problem fetching instances");
			e.printStackTrace();
		}
		
	}
	
	/**
	 * 
	 * Look at things that have been deleted since the last release
	 * and look to see if they have a corresponding "_Deleted" instance.
	 * If so, copy the curator comment over into the identifier database.
	 */
	public void generateDeletionComments(GKInstance previousInstance, boolean testMode) {
		try {
			Long dbId = previousInstance.getDBID();
			
			GKInstance currentInstance = currentDba.fetchInstance(dbId);
			// Instance exists in current release too, i.e. has not
			// been delteted/suppressed, so we don't need to continue.
			if (currentInstance!=null)
				return;
			
			// Get StableIdentifier instance from release database
			GKInstance stableIdentifier = (GKInstance)previousInstance.getAttributeValue("stableIdentifier");
			if (stableIdentifier==null)
				return;
			
			// Get _Deleted instance corresponding to dbId.  These are
			// only available from gk_central.
			Collection deleteds = gk_centraldba.fetchInstanceByAttribute("_Deleted", "deletedInstanceDB_ID", "=", dbId);
			if (deleteds==null || deleteds.size()==0)
				return;
			
			GKInstance deleted = (GKInstance)deleteds.toArray()[0];
			String curatorComment = (String)deleted.getAttributeValue("curatorComment");
			GKInstance reason = (GKInstance)deleted.getAttributeValue("reason");
			List replacementInstances = deleted.getAttributeValuesList("replacementInstances");
			if ((curatorComment==null || curatorComment.equals("")) &&
				reason==null &&
				(replacementInstances==null || replacementInstances.size()==0))
				return;
			String reasonText = "";
			if (reason!=null)
				reasonText = (String)reason.getAttributeValue("name");
			
			// Create a new Deleted instance for the identifier database and
			// transfer appropriate information to it
			GKInstance idbDeleted = identifierDatabase.createDeleted();
			idbDeleted.setAttributeValue("comment", curatorComment);
			idbDeleted.setAttributeValue("reason", reasonText);
			if (replacementInstances!=null) {
				for (Iterator it = replacementInstances.iterator(); it.hasNext();) {
					GKInstance replacementInstance = (GKInstance)it.next();
					GKInstance replacement = identifierDatabase.createReplacement();
					Long replacementDB_ID = replacementInstance.getDBID();
					int replacementDB_IDInt = replacementDB_ID.intValue();
					if (replacementDB_IDInt>=0)
						replacement.setAttributeValue("replacementDB_ID", new Integer(replacementDB_IDInt));
					GKInstance replacementStableIdentifier = (GKInstance)replacementInstance.getAttributeValue("stableIdentifier");
					if (replacementStableIdentifier!=null) {
						String replacementIdentifierString = (String)replacementStableIdentifier.getAttributeValue("identifier");
						replacement.setAttributeValue("replacementIdentifierString", replacementIdentifierString);
					}
					idbDeleted.addAttributeValue("replacement", replacement);
				}
			}
			idbDeleted.setAttributeValue("releaseNum", currentReleaseNum);
			
			String identifier = (String)stableIdentifier.getAttributeValue("identifier");
			
			// Get StableIdentifier instance from identifier database
			stableIdentifier = IdentifierDatabase.getStableIdentifierInstance(identifier, false);
			if (stableIdentifier==null)
				return;
			
			stableIdentifier.setAttributeValue("deleted", idbDeleted);
			
			if (!testMode) {
				MySQLAdaptor identifierDatabaseDba = IdentifierDatabase.getDba();
				identifierDatabaseDba.updateInstanceAttribute(stableIdentifier, "deleted");
			}
		} catch (Exception e) {
			System.err.println("IDGenerator.generateDoNotReleaseIDs: problem fetching instances");
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Takes an instance and generates a stable IDs for
	 * it.
	 * 
	 * @param schemaClass
	 * @param testMode - if true, nothing will be inserted into database
	 */
	public void generateIDs(InstanceBiologicalMeaning instanceBiologicalMeaning, GKInstance currentInstance, boolean testMode, List schemaChangeIgnoredAttributes) {
		try {
			// If the current release already has a stable identifier,
			// log the fact.
			if (currentInstance.getAttributeValue("stableIdentifier")!=null) {
				tests.addInstance(IDGeneratorTest.ST_IDS_EXIST, currentInstance);
			}
				
			// Get the previous instance (if there is one) and determine
			// its stable ID.
			previousInstanceFinder.setCurrentInstance(currentInstance);
			if (!previousInstanceFinder.isStableIdentifierAllowed())
				return;
			previousInstanceFinder.setPreviousReleaseNum(identifierDatabase.getReleaseNumFromReleaseDba(previousDba));
			GKInstance previousInstance = previousInstanceFinder.getPreviousInstance();
			if (previousInstanceFinder.isIDsFromUnspecifiedReleases()) {
				System.err.println("IDGenerator.generateIDs: stable ID obtained from previous release");
				tests.addInstance(IDGeneratorTest.ID_IN_OLD_RELEASE, currentInstance);
			}
			GKInstance previousStableID = null;
			if (previousInstance != null)
				previousStableID = (GKInstance)previousInstance.getAttributeValue("stableIdentifier");
			
			// Create the StableIdentifier instance to be inserted in
			// the current release
			GKInstance currentStableID = new GKInstance();
			currentStableID.setSchemaClass(currentDba.getSchema().getClassByName("StableIdentifier"));
			currentStableID.setDbAdaptor(currentDba);

			// If the previous version of this instance already
			// had a stable ID, pass it over to the current release,
			// otherwise generate a new stable ID.
			String stableIdentifierString = null;
			String stableVersionString = null;
			GKInstance identifierDbStableIdentifier;
			tests.addInstance(IDGeneratorTest.ST_IDS_INSERTED, currentInstance);
			Long dbId = currentInstance.getDBID();
			if (previousStableID==null) {
				// Current instance has no previous stable ID - maybe the
				// instance is new, or this is the first time that stable
				// IDs have been generated, or perhaps the DB_ID has been
				// changed.
				tests.addInstance(IDGeneratorTest.NO_PREVIOUS_DB_ID, currentInstance);
				
				// Get a never-before-used stable ID - if the identifier database
				// is virgin, create a fresh one.  identifierDbStableIdentifier
				// should NEVER be null.  Doing this in test mode is maybe a bit
				// wasteful, but it doesn't actually do any harm.
				if (!identifierDatabase.incrementMostRecentStableIdentifier()) {
					tests.addInstance(IDGeneratorTest.COULD_NOT_INC_ST_ID, currentInstance);
					System.err.println("IDGenerator.generateIDs: cannot find stable identifier " + stableIdentifierString + " in identifier database!!");
//					return;
				}
				identifierDbStableIdentifier = IdentifierDatabase.getMostRecentStableIdentifierFromState();
				
				// retrieve stable identifier and version for insertion
				// into the Reactome database
				stableIdentifierString = (String)identifierDbStableIdentifier.getAttributeValue("identifierString");
				stableVersionString ="1"; // initial version number
				
				// Create the hierarchy of classes below StableIdentifier
				// in the identifier database
				identifierDatabase.insertNewVersion(identifierDbStableIdentifier, stableVersionString, currentReleaseNum, dbId, testMode);
			} else {
//				String previousReleaseNum = identifierDatabase.getReleaseNumFromReleaseDba(previousDba);
				String previousReleaseNum = previousInstanceFinder.getPreviousReleaseNum();
				
				// TODO: we ought to extract these values from the identifier
				// database rather than from the slice, to avoid problems
				// when people inadvertantly run stable ID creation more than
				// once.
				stableIdentifierString = (String)previousStableID.getAttributeValue("identifier");
				stableVersionString = (String)previousStableID.getAttributeValue("identifierVersion");
				
				Set stableIdentifiers = IdentifierDatabase.getStableIdentifiersFromReleaseDB_ID(previousReleaseNum, dbId);
				if (stableIdentifiers.size()!=1) {
					if (stableIdentifiers.size()<1) {
						System.err.println("IDGenerator.generateIDs: no stable ID set for DB_ID=" + dbId + "; something is very wrong!!");
					} else if (stableIdentifiers.size()>1) {
						System.err.println("IDGenerator.generateIDs: multiple stable IDs for DB_ID=" + dbId + "; it is likely that stable ID generation has been run twice during a release");
					}
					
					// This is a bit ugly: extract stable ID information from
					// slice database.  Can potentially lead to the propagation
					// of inconsistancies if stable ID generation is done more
					// than once during a release.
					stableIdentifierString = (String)previousStableID.getAttributeValue("identifier");
					stableVersionString = (String)previousStableID.getAttributeValue("identifierVersion");
				} else {
					// This is the clean way to do things, if the stable ID database
					// is in a consistent state: look up the stable ID and the most
					// recent version for the DB_ID in the stable ID database.
					stableIdentifierString = (String)(((GKInstance)(stableIdentifiers.toArray()[0])).getAttributeValue("identifierString"));
					stableVersionString = IdentifierDatabase.getStableIdentifierVersionForReleaseString(stableIdentifierString, previousReleaseNum);
				}
				
				// Sanity crosscheck
				if (!stableIdentifierString.equals((String)previousStableID.getAttributeValue("identifier")))
					System.err.println("IDGenerator.generateIDs: mismatch between stable ID extracted from identifier database (" + stableIdentifierString + ") and slice (" + (String)previousStableID.getAttributeValue("identifier") + ") for DB_ID=" + dbId);
				if (!stableVersionString.equals((String)previousStableID.getAttributeValue("identifierVersion")))
					System.err.println("IDGenerator.generateIDs: mismatch between version extracted from identifier database (" + stableVersionString + ") and slice (" + (String)previousStableID.getAttributeValue("identifierVersion") + ") for DB_ID=" + dbId);
				
				// Increment the version number if any attributes have changed
				// from the previous to the current release.
				if (instanceBiologicalMeaning.isBiologicalMeaningChanged(previousInstance, currentInstance, schemaChangeIgnoredAttributes)) {
					int stableVersionNum = 0;
					try {
						stableVersionNum = (new Integer(stableVersionString)).intValue();
						instanceBiologicalMeaning.biologicalMeaningChanged(previousInstance, currentInstance);
						tests.addInstance(IDGeneratorTest.BIOLOGICAL_MEANING_CHANGED, currentInstance);
					} catch (NumberFormatException e) {
						// This shouldn't happen
						System.err.println("IDGenerator.generateIDs: inappropriate stableVersionString, setting stableVersionNum to 0");
						e.printStackTrace();
					}
					stableVersionNum++;
					stableVersionString = (new Integer(stableVersionNum)).toString();
					
//					System.err.println("IDGenerator.generateIDs: stableVersionString=" + stableVersionString);
					
				}
				
				// Get a StableIdentifier object corresponding to stableIdentifierString
				// from the identifier database, if one already exists.
				identifierDbStableIdentifier = IdentifierDatabase.getStableIdentifierInstance(stableIdentifierString, false);
				if (identifierDbStableIdentifier==null) {
					// Something a bit nasty has happened if we find a stable ID
					// in a release but not in the identifier database.  Log this
					// fact as a test result, and then 
					// create a new StableIdentifier instance in the identifier database to plug the gap.
					identifierDbStableIdentifier = IdentifierDatabase.getStableIdentifierInstance(stableIdentifierString, true);
					tests.addInstance(IDGeneratorTest.MISSING_STABLE_ID, currentInstance);

//					// Create a new stable ID - dangerous things (like duplicated
//					// IDs) happen if you try to recycle old stable IDs.
//					identifierDbStableIdentifier = identifierDatabase.getMostRecentStableIdentifierFromState();
//					
//					// retrieve stable identifier and version for insertion
//					// into the Reactome database
//					stableIdentifierString = (String)identifierDbStableIdentifier.getAttributeValue("identifierString");
//					stableVersionString ="1"; // initial version number

					System.err.println("IDGenerator.generateIDs: cannot find stable identifier " + stableIdentifierString + " in identifier database, creating fresh one.");
				}
				if (identifierDbStableIdentifier==null) {
					System.err.println("IDGenerator.generateIDs: cannot find or create stable identifier " + stableIdentifierString + " in identifier database!!");
//					return;
				}

				// Update the hierarchy of classes below StableIdentifier
				// in the identifier database
				identifierDatabase.insertNewVersion(identifierDbStableIdentifier, stableVersionString, currentReleaseNum, dbId, testMode, instanceBiologicalMeaning);
				instanceBiologicalMeaning.resetChangeRecords();
				
				// This stuff does some sanity testing.  Look at the
				// stable ID(s) in the *current* release to see if
				// they are the same as the one in the previous release.
				// If not, it strongly suggests that a discrepancy has
				// crept into the identifier database that needs correcting.
				Long previous_DB_ID = previousInstance.getDBID();
				String currentReleaseNum = identifierDatabase.getReleaseNumFromReleaseDba(currentDba);
				stableIdentifiers = IdentifierDatabase.getStableIdentifiersFromReleaseDB_ID(currentReleaseNum, previousInstance.getDBID());
				if (stableIdentifiers.size()<1) {
					System.err.println("IDGenerator.generateIDs: testing, no stable ID set for DB_ID=" + previous_DB_ID + "; something is very wrong!!");
				} else if (stableIdentifiers.size()>1) {
					System.err.println("IDGenerator.generateIDs: testing, multiple stable IDs for DB_ID=" + previous_DB_ID + "; it is likely that stable ID generation has been run twice during a release");
				} else {
					String currentIdentifierString = (String)(((GKInstance)(stableIdentifiers.toArray()[0])).getAttributeValue("identifierString"));
					if (!stableIdentifierString.equals(currentIdentifierString)) {
						System.err.println("IDGenerator.generateIDs: testing, for DB_ID=" + previous_DB_ID + ", release " + previousReleaseNum + " stable ID=" + stableIdentifierString + " but release " + currentReleaseNum + " stable ID=" + currentIdentifierString);
					}
				}
			}

			// Put stable ID and version number into stable ID instance for
			// current release.
			currentStableID.setAttributeValue("identifier", stableIdentifierString);
			currentStableID.setAttributeValue("identifierVersion", stableVersionString);
			
			currentInstance.setAttributeValue("stableIdentifier", currentStableID);
			
			if (!testMode) {
//				// This is a new instance, so store it.
//				currentDba.storeInstance(currentStableID);
				
				// Update the instance in the current release so that it
				// contains the appropriate stable ID info.
				currentDba.updateInstanceAttribute(currentInstance, "stableIdentifier");
			}
		} catch (Exception e) {
			System.err.println("IDGenerator.generateIDs: problem fetching instances");
			e.printStackTrace();
		}
	}
	
	/**
	 * If the list of classes contains a class and its super class,
	 * only the super class will be retained.
	 * 
	 * Assumption: super classes always occur before classes in the
	 * list order.
	 * 
	 * @param classes
	 * @return
	 */
	private List consolidateClassList(List classes) {
		List consolidatedClasses = new ArrayList();
		
		if (classes==null)
			return null;
		
		boolean topLevel;
		for (Iterator it = classes.iterator(); it.hasNext();) {
			SchemaClass schemaClass = (SchemaClass)it.next();
			Collection superClasses = schemaClass.getSuperClasses();
			topLevel = true; // assume schemaClass is top-level
			for (Iterator it1 = consolidatedClasses.iterator(); it1.hasNext();) {
				SchemaClass consolidatedSchemaClass = (SchemaClass)it1.next();
				
				for (Iterator it2 = superClasses.iterator(); it2.hasNext();) {
					SchemaClass superClass = (SchemaClass)it2.next();
					if (superClass==consolidatedSchemaClass) {
						// oh dear, schemaClass is not top-level
						topLevel = false;
						break;
					}
				}
				if (!topLevel)
					break;
			}
			
			if (topLevel)
				consolidatedClasses.add(schemaClass);
		}
		
		return consolidatedClasses;
	}
	
	/**
	 * Takes the list of schema classes and generates stable IDs for
	 * all instances in these classes.  Nothing is inserted into
	 * the databases.
	 * 
	 * @param classes
	 */
	public void testIDs(List classes) {
		generateIDs(classes, true, null);
	}
	
	/** 
	 *  Gets the List of tests.
	 */
	public IDGeneratorTests getTests() {
		return tests;
	}
	
	/** 
	 *  Removes all stable IDs and version numbers
	 *  from the current release.
	 *  
	 *  Additionally removes all references to these
	 *  IDs from the identifier database.
	 */
	public void rollbackIDs(List classes) {
		if (classes==null)
			return;
		
		List consolidatedClasses = consolidateClassList(classes);
		
		// Go through all instances of each schema class
		for (Iterator it = consolidatedClasses.iterator(); it.hasNext();) {
			SchemaClass currentSchemaClass = (SchemaClass)it.next();
			
			rollbackIDs(currentSchemaClass);
		}
	}
	
	/**
	 * Takes a schema class and removes stable IDs from
	 * all instances in this class.
	 * 
	 * @param schemaClass
	 */
	public void rollbackIDs(SchemaClass currentSchemaClass) {
		if (currentDba==null) {
			System.err.println("IDGenerator.rollbackIDs: currentDba==null!");
			return;
		}

		try {
			Collection currentInstances = currentDba.fetchInstancesByClass(currentSchemaClass);
			
			for (Iterator it = currentInstances.iterator(); it.hasNext();) {
				GKInstance currentInstance = (GKInstance)it.next();
				rollbackIDs(currentInstance);
			}
		} catch (Exception e) {
			System.err.println("IDGenerator.rollbackIDs: problem fetching instances");
			e.printStackTrace();
		}
	}
	/**
	 * Takes an instance and removes a stable IDs from
	 * it.
	 * 
	 * @param schemaClass
	 */
	public void rollbackIDs(GKInstance currentInstance) {
		try {
			GKInstance currentStableID = (GKInstance)currentInstance.getAttributeValue("stableIdentifier");
			
			// Nothing to roll back
			if (currentStableID==null)
				return;
				
			String identifier = (String)currentStableID.getAttributeValue("identifier");
			String identifierVersion = (String)currentStableID.getAttributeValue("identifierVersion");

			GKInstance identifierDbStableIdentifier = IdentifierDatabase.getStableIdentifierInstance(identifier, false);

			Long dbId = currentInstance.getDBID();

			// Update the hierarchy of classes below StableIdentifier
			// in the identifier database
			identifierDatabase.deleteVersion(identifierDbStableIdentifier, identifierVersion, currentReleaseNum, dbId);

			// Delete the StableIdentifier instance from the Reactome database
			currentDba.deleteInstance(currentStableID);
			
			// Update the instance in the current release so that it
			// contains the appropriate stable ID info.
			currentInstance.emptyAttributeValues("stableIdentifier");
			currentDba.updateInstanceAttribute(currentInstance, "stableIdentifier");
		} catch (Exception e) {
			System.err.println("IDGenerator.rollbackIDs: problem fetching instances");
			e.printStackTrace();
		}
	}
}

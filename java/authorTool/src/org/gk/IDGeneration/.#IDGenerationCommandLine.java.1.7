/*
 * Created on Dec 15, 2005
 */
package org.gk.IDGeneration;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.swing.JFrame;

import org.gk.model.GKInstance;
import org.gk.persistence.MySQLAdaptor;
import org.gk.schema.Schema;
import org.gk.schema.SchemaClass;

/** 
 *  This is the main class for the IDGeneration program,
 *  using a command line interface.  Usage:
 *  
 *  java org.gk.IDGeneration.IDGenerationCommandLine <options>
 *  
 *  The following options are available:
 *  
 *  -f force all questions to be answered with "yes"
 *     (allows non-interactive use)
 *  -t run in test mode (nothing inserted into datbases)
 *  -h <hostname> default hostname for all databases
 *  -u <username> default user name for all databases
 *  -p <port> default port for all databases
 *  -P <password> default password for all databases
 *  -prnum <release> release number of previous release
 *  -cdbname <db name> database name of current release
 *  -crnum <release> release number of current release
 *  -idbname <db name> database name of identifier database
 *  -gdbname <db name> database name of gk_central
 *  -s <schema classes> comma-separated list of schema classes
 *     e.g. Pathway,Reaction
 *  
 *  If you intend to run the program without human supervision
 *  (e.g. in a script) you should include the -f option
 *  in the command line, otherwise the program will get
 *  stuck as soon as it tries to interact with the user.
 *  
 *  If problems occur during ID generation, they will be
 *  reported on STDERR.  If the program runs successfully
 *  to completion, the results of the internally executed
 *  tests will be printed out, giving a summary of the
 *  ID generation process.
 *  
 * @author croft
 */
public class IDGenerationCommandLine  extends JFrame {
	private IncludeInstances includeInstances;
	private boolean force;
	private boolean testMode;
	private boolean orthologyMode;
	private String previousReleaseNum;
	private String currentReleaseNum;
	private DbParams currentDbParams;
	private DbParams identifierDbParams;
	private DbParams gk_centralDbParams;
	private List schemaClasseNames;
	private IdentifierDatabase identifierDatabase = new IdentifierDatabase();
	
	public IDGenerationCommandLine() {
		init();
	}
	
	public boolean isForce() {
		return force;
	}

	public void setForce(boolean force) {
		this.force = force;
	}

	public boolean isTestMode() {
		return testMode;
	}

	public void setTestMode(boolean testMode) {
		this.testMode = testMode;
	}

	public boolean isOrthologyMode() {
		return orthologyMode;
	}

	public void setOrthologyMode(boolean orthologyMode) {
		this.orthologyMode = orthologyMode;
	}

	public void setHostname(String hostname) {
		if (currentDbParams.hostname.equals(""))
			currentDbParams.hostname = hostname;
		if (identifierDbParams.hostname.equals(""))
			identifierDbParams.hostname = hostname;
		if (gk_centralDbParams.hostname.equals(""))
			gk_centralDbParams.hostname = hostname;
	}

	public void setPassword(String password) {
		if (currentDbParams.password.equals(""))
			currentDbParams.password = password;
		if (identifierDbParams.password.equals(""))
			identifierDbParams.password = password;
		if (gk_centralDbParams.password.equals(""))
			gk_centralDbParams.password = password;
	}

	public void setPort(String port) {
		if (currentDbParams.port.equals(""))
			currentDbParams.port = port;
		if (identifierDbParams.port.equals(""))
			identifierDbParams.port = port;
		if (gk_centralDbParams.port.equals(""))
			gk_centralDbParams.port = port;
	}

	public void setUsername(String username) {
		if (currentDbParams.username.equals(""))
			currentDbParams.username = username;
		if (identifierDbParams.username.equals(""))
			identifierDbParams.username = username;
		if (gk_centralDbParams.username.equals(""))
			gk_centralDbParams.username = username;
	}

	public String getPreviousReleaseNum() {
		return previousReleaseNum;
	}

	public void setPreviousReleaseNum(String previousReleaseNum) {
		this.previousReleaseNum = previousReleaseNum;
	}

	public String getCurrentReleaseNum() {
		return currentReleaseNum;
	}

	public void setCurrentReleaseNum(String currentReleaseNum) {
		this.currentReleaseNum = currentReleaseNum;
	}

	public List getSchemaClasseNames() {
		return schemaClasseNames;
	}

	public void setSchemaClasseNames(List schemaClasses) {
		this.schemaClasseNames = schemaClasses;
	}

	private void init() {
		includeInstances = new IncludeInstances();
		force = false;
		testMode = false;
		schemaClasseNames = new ArrayList();
		currentDbParams = new DbParams();
		identifierDbParams = new DbParams();
		gk_centralDbParams = new DbParams();
	}
	
    public void run() {
    	// Check arguments
    	if (!testMode)
    		handleYesNo("Running this program will change live databases irreversibly.");
    	
    	int previousReleaseNumInt = (-1);
    	int currentReleaseNumInt = (-1);
    	
		if (previousReleaseNum==null)
	    	handleYesNo("You have not specified a previous release, new stable IDs will be created from scratch.");
		else {
	    	try {
				previousReleaseNumInt = (new Integer(previousReleaseNum)).intValue();
				if (previousReleaseNumInt<1)
					handleError("Invalid previous release number " + previousReleaseNum);
			} catch (NumberFormatException e) {
				handleError("Previous release number (" + previousReleaseNum + ")is not recognisably numeric");
			}
		}

		if (currentReleaseNum==null)
	    	handleError("You have not specified a current release, aborting!");
		else {
			try {
				currentReleaseNumInt = (new Integer(currentReleaseNum)).intValue();
				if (currentReleaseNumInt<1)
					handleError("Invalid current release number " + currentReleaseNum);
			} catch (NumberFormatException e) {
				handleError("Previous release number (" + currentReleaseNum + ")is not recognisably numeric");
			}
		}
		
		if (previousReleaseNum!=null && currentReleaseNumInt - previousReleaseNumInt != 1)
			handleYesNo("Current release (" + currentReleaseNum + ") is not a direct successor of previous release (" + previousReleaseNum + ").");

    	// In "orthologyMode", look into release databases (rather than the
    	// default slice databases) for matching orthologous events that
    	// could be assigned stable IDs.
    	if (orthologyMode) {
    		identifierDatabase.setDbParamsAttribute(IdentifierDatabase.RELEASE);
    	}

		MySQLAdaptor identifierDbParamsDba = identifierDbParams.getDba();
		if (identifierDbParamsDba==null)
			handleError("Could not create connection to identifier database - maybe you entered the wrong parameters?");
		IdentifierDatabase.setDba(identifierDbParamsDba);
    	
		String lastNonNullReleaseNum = IdentifierDatabase.getLastNonNullReleaseNum();
		try {
			int lastNonNullReleaseNumInt = (new Integer(lastNonNullReleaseNum)).intValue();
			if (currentReleaseNumInt<lastNonNullReleaseNumInt)
				handleYesNo("Current release (" + currentReleaseNum + ") is not the last in the release list (" + lastNonNullReleaseNum + ").");
		} catch (NumberFormatException e) {
		}
		
    	// Set up a database adaptor for the previous release,
    	// if one has been specified.
		System.err.println("Get DBA for previous release");
		MySQLAdaptor previousDba = null;
		try {
			System.err.println("About to do a getReleaseDbaFromReleaseNum");
			previousDba = identifierDatabase.getReleaseDbaFromReleaseNum(previousReleaseNum);
		} catch (Exception e1) {
			// This is to take care of the case where username and
			// password have not been stored in the identifier
			// database for security reasons.
			System.err.println("Retry getReleaseDbaFromReleaseNum using user and password from current release");
			previousDba = identifierDatabase.getReleaseDbaFromReleaseNum(previousReleaseNum, currentDbParams.username, currentDbParams.password);
		}
		if (previousDba==null && previousReleaseNum!=null)
			handleError("Cannot find a previous release, with release number " + previousReleaseNum);
		
		MySQLAdaptor currentDba = currentDbParams.getDba();
		if (currentDba==null)
			handleError("Could not create connection to current release database - maybe you entered the wrong parameters?");
		MySQLAdaptor gk_centraldba = gk_centralDbParams.getDba();			
		if (gk_centralDbParams.dbName!=null && gk_centraldba==null)
			handleError("Could not create connection to " + gk_centralDbParams.dbName + " - maybe you entered the wrong parameters?");

    	PreviousInstanceFinder previousInstanceFinder = new DbIdPreviousInstanceFinder(currentReleaseNum, previousDba, true, identifierDatabase);
    	// In "orthologyMode", find previous instances via orthologous
    	// event attributes, rather than by DB_ID
    	if (orthologyMode) {
    		previousInstanceFinder = new OrthologousEventPreviousInstanceFinder(currentReleaseNum, previousDba, true, identifierDatabase);
    	}
    	
		// Create a new release and add it to the identifier database
    	setCurrentReleaseParams();
    	
    	// Use the default class set if the user hasn't explicitly
    	// specified which classes should be used for stable ID
    	// generation.
    	if (schemaClasseNames.size()==0) {
    		String[] defaultClasses = includeInstances.getDefaultClasses();
    		for (int i=0; i<defaultClasses.length; i++)
    			schemaClasseNames.add(defaultClasses[i]);
    	}
    	
    	// Replace schema class names with true schema classes
    	List schemaClasses = new ArrayList();
    	try {
			Schema currentSchema = currentDba.fetchSchema();
			String schemaClassName;
			SchemaClass schemaClass;
			for (Iterator itc = schemaClasseNames.iterator(); itc.hasNext();) {
				schemaClassName = (String)itc.next();
				schemaClass = currentSchema.getClassByName(schemaClassName);
				if (schemaClass==null)
					handleError("Schema class " + schemaClassName + " not known in current release");
				schemaClasses.add(schemaClass);
			}
		} catch (Exception e) {
			handleError("Error getting schema classes");
		}

    	
    	// Get the highest level classes that include all of the
    	// classes specified.
    	List rootClasses = includeInstances.extractRootClasses(schemaClasses);
    	
    	// Make sure there are no "forbidden classes" in the list.
    	List cleanClasses = includeInstances.removeForbiddenClasses(schemaClasses);
    	
    	// Now do the actual stable ID generation
		IDGenerator idGenerator = new IDGenerator(previousDba, currentDba, gk_centraldba, identifierDatabase, previousInstanceFinder);
    	idGenerator.generateIDs(cleanClasses);
    	
    	// Print out the test results
    	IDGeneratorTests iDGeneratorTests = idGenerator.getTests();
    	System.out.print(iDGeneratorTests.toString());
    }
    
    private void setCurrentReleaseParams() {
    	GKInstance release = IdentifierDatabase.createBlankRelease();

    	try {
			MySQLAdaptor instanceDatabaseDba = IdentifierDatabase.getDba();
			
			// First look to see if the release number already exists;
			// don't proceed any further with the method if so.
			Collection instances = instanceDatabaseDba.fetchInstanceByAttribute("Release", "num", "=", currentReleaseNum);
			if (instances.size()>0)
				return;
			
			// Insert a new DbParams instance, if necessary
			GKInstance dbParams = new GKInstance();
			dbParams.setSchemaClass(instanceDatabaseDba.getSchema().getClassByName("DbParams"));
			dbParams.setDbAdaptor(instanceDatabaseDba);
			dbParams.setAttributeValue("host", currentDbParams.hostname);
			dbParams.setAttributeValue("user", currentDbParams.username);
			dbParams.setAttributeValue("dbName", currentDbParams.dbName);
			dbParams.setAttributeValue("pwd", currentDbParams.password);
			dbParams.setAttributeValue("port", currentDbParams.port);

			release.setAttributeValue("sliceDbParams", dbParams);
			release.setAttributeValue("num", currentReleaseNum);
			
			// This stuff has to be inserted into the identifier
			// database, otherwise the rest of the code fails
//			if (!testMode) {
				// These are new instances, so store them.
				instanceDatabaseDba.storeInstance(dbParams);
				instanceDatabaseDba.storeInstance(release);
//			}
		} catch (Exception e) {
			handleError("Problem setting database parameters for the current release");
		}
    }
    
    private void handleError(String text) {
    	System.err.println(text);
    	System.exit(1);
    }
    
    private void handleYesNo(String text) {
    	if (force)
    		return;
    	
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		System.out.println(text);
		System.out.print("Are you sure you want to do this?  (y/n) ");
		String answer = "n";
		try {
			answer = reader.readLine();
		} catch (IOException e) {
		}
		if (answer.equals("n"))
			System.exit(0);
    }
    
    static private void printHelp() {
    	System.out.println("Usage:");
    	System.out.println("");
    	System.out.println("java org.gk.IDGeneration.IDGenerationCommandLine <options>");
    	System.out.println("");
    	System.out.println("The following options are available:");
    	System.out.println("");
    	System.out.println(" -f force all questions to be answered with \"yes\"");
    	System.out.println("    (allows non-interactive use)");
    	System.out.println(" -o create only stable IDs for events derived from");
    	System.out.println("    orthology prediction (uses release DBs)");
    	System.out.println(" -t run in test mode (nothing inserted into datbases)");
    	System.out.println(" -h <hostname> default hostname for all databases");
    	System.out.println(" -u <username> default user name for all databases");
    	System.out.println(" -p <port> default port for all databases");
    	System.out.println(" -P <password> default password for all databases");
    	System.out.println(" -prnum <release> release number of previous release");
    	System.out.println(" -cdbname <db name> database name of current release");
    	System.out.println(" -crnum <release> release number of current release");
    	System.out.println(" -idbname <db name> database name of identifier database");
    	System.out.println(" -gdbname <db name> database name of gk_central");
    	System.out.println(" -s <schema classes> comma-separated list of schema classes");
    	System.out.println("    e.g. Pathway,Reaction");
    	
    	System.exit(0);
    }
    
	static public void main(String[] args) {
		IDGenerationCommandLine iDGenerationCommandLine = new IDGenerationCommandLine();
		
		// Parse arguments
		String s;
		for (int i=0; i<args.length; i++) {
			s = args[i];
			if (s.equals("-f"))
				iDGenerationCommandLine.setForce(true);
			else if (s.equals("-o"))
				iDGenerationCommandLine.setOrthologyMode(true);
			else if (s.equals("-t"))
				iDGenerationCommandLine.setTestMode(true);
			else if (s.equals("-h")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.setHostname(args[i]);
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-u")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.setUsername(args[i]);
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-p")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.setPort(args[i]);
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-P")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.setPassword(args[i]);
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-prnum")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.setPreviousReleaseNum(args[i]);
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-cdbname")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.currentDbParams.dbName = args[i];
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-crnum")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.setCurrentReleaseNum(args[i]);
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-idbname")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.identifierDbParams.dbName = args[i];
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-gdbname")) {
				i++;
				if (i<args.length)
					iDGenerationCommandLine.gk_centralDbParams.dbName = args[i];
				else {
					System.err.println("IDGenerationCommandLine: missing argument");
					System.exit(1);
				}
			}
			else if (s.equals("-s")) {
				i++;
				if (i<args.length) {
					String[] splits = args[i].split(",");
					List schemaClasseNames = new ArrayList();
					for (int j=0; j<splits.length; j++)
						schemaClasseNames.add(splits[j]);
					iDGenerationCommandLine.setSchemaClasseNames(schemaClasseNames);
				} else {
					iDGenerationCommandLine.handleError("IDGenerationCommandLine: missing argument");
				}
			}
			else if (s.equals("--help") || s.equals("-help")) {
				iDGenerationCommandLine.printHelp();
			} else
				iDGenerationCommandLine.handleError("Unknown argument" + args[i]);
		}
		
		// Alright, puff, pant, we now have all the things we need
		// to know to actually go ahead and generate stable IDs for
		// the new release.
		iDGenerationCommandLine.run();
	}
	
	/**
	 * Lightweight class for holding parameters for various
	 * databases.
	 * 
	 * @author croft
	 *
	 */
	class DbParams {
		public String dbName = "";
		public String hostname = "";
		public String username = "";
		public String port = "";
		public String password = "";
		
		public MySQLAdaptor getDba() {
			MySQLAdaptor dba = null;
			
			try {
				dba = new MySQLAdaptor(hostname, dbName, username, password, Integer.parseInt(port));
			} catch (NumberFormatException e) {
				System.err.println("IDGenerationCommandLine.DbParams.getDba: port number is strange: " + port);
				e.printStackTrace();
			} catch (SQLException e) {
				System.err.println("IDGenerationCommandLine.DbParams.getDba: something went wrong with mysql");
				e.printStackTrace();
			} catch (Exception e) {
				System.err.println("IDGenerationCommandLine.DbParams.getDba: something went wrong");
				e.printStackTrace();
			}
			
			return dba;
		}
	}
}
